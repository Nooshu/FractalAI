import { generatePaletteTexture } from '../utils.js';

// Generate vertices for the Sierpinski Arrowhead Curve
// The curve is generated by recursively replacing a line segment with three segments
// forming an arrowhead pattern (equilateral triangle with base removed)
// The curve fills a triangle and alternates direction at each level
function generateSierpinskiArrowhead(iterations) {
  const vertices = [];

  // Helper function to generate the arrowhead curve
  // Replaces a line segment from (x1, y1) to (x2, y2) with three segments
  // direction: 1 for left-pointing, -1 for right-pointing
  function arrowhead(x1, y1, x2, y2, depth, direction) {
    if (depth >= iterations) {
      // At maximum depth, add the endpoint
      if (depth === iterations) {
        vertices.push(x2, y2);
      }
      return;
    }

    // Calculate the three points that replace the line segment
    // The segment is divided into three parts with an arrowhead in the middle

    // One-third and two-thirds points along the original segment
    const dx = x2 - x1;
    const dy = y2 - y1;
    const x1_3 = x1 + dx / 3;
    const y1_3 = y1 + dy / 3;
    const x2_3 = x1 + (2 * dx) / 3;
    const y2_3 = y1 + (2 * dy) / 3;

    // Calculate the tip of the arrowhead
    // The tip forms an equilateral triangle with the one-third and two-thirds points
    const segmentLength = Math.sqrt((x2_3 - x1_3) ** 2 + (y2_3 - y1_3) ** 2);
    const height = (segmentLength * Math.sqrt(3)) / 2;

    // Perpendicular vector to the segment
    const perpX = -dy;
    const perpY = dx;
    const perpLength = Math.sqrt(perpX ** 2 + perpY ** 2);

    // Normalize and scale the perpendicular vector
    const normalizedPerpX = (perpX / perpLength) * height;
    const normalizedPerpY = (perpY / perpLength) * height;

    // Midpoint of the middle segment
    const midX = (x1_3 + x2_3) / 2;
    const midY = (y1_3 + y2_3) / 2;

    // The tip point (direction determines which side)
    const tipX = midX + normalizedPerpX * direction;
    const tipY = midY + normalizedPerpY * direction;

    // Recursively generate the three segments
    // Segment 1: (x1, y1) -> (x1_3, y1_3)
    arrowhead(x1, y1, x1_3, y1_3, depth + 1, direction);

    // Segment 2: (x1_3, y1_3) -> tip -> (x2_3, y2_3)
    arrowhead(x1_3, y1_3, tipX, tipY, depth + 1, -direction);
    arrowhead(tipX, tipY, x2_3, y2_3, depth + 1, -direction);

    // Segment 3: (x2_3, y2_3) -> (x2, y2)
    arrowhead(x2_3, y2_3, x2, y2, depth + 1, direction);
  }

  // Start with a base equilateral triangle
  // The triangle is centered at origin
  const h = 0.866; // Height of equilateral triangle (sqrt(3)/2)
  const w = 1.0; // Half width

  // Three vertices of the base triangle
  const topX = 0;
  const topY = h * 0.67; // Top vertex
  const leftX = -w;
  const leftY = -h * 0.33; // Bottom left
  const rightX = w;
  const rightY = -h * 0.33; // Bottom right

  // Start from the top vertex
  vertices.push(topX, topY);

  // Generate the curve by traversing the three sides of the triangle
  // The curve alternates direction to fill the triangle
  arrowhead(topX, topY, leftX, leftY, 0, 1);
  arrowhead(leftX, leftY, rightX, rightY, 0, -1);
  arrowhead(rightX, rightY, topX, topY, 0, 1);

  return new Float32Array(vertices);
}

const vertexShader = `
  precision mediump float;
  attribute vec2 position;
  uniform float uZoom;
  uniform vec2 uOffset;
  uniform vec2 uResolution;
  uniform float uXScale;
  uniform float uYScale;
  varying vec2 vPosition;

  void main() {
    float aspect = uResolution.x / uResolution.y;
    float scale = 4.0 / uZoom;
    
    // Transform vertex position to match the standard fractal coordinate system
    // For line-based fractals, maintain aspect ratio correctly
    vec2 fractalCoord = position;
    vec2 relative = fractalCoord - uOffset;
    
    // Scale uniformly (same factor for x and y) to preserve shape
    vec2 scaled = vec2(
      relative.x / (scale * uXScale),
      relative.y / (scale * uYScale)
    );
    
    // Apply aspect ratio correction to maintain shape across different window sizes
    // Divide x by aspect to compensate for wider screens, preserving the curve's proportions
    scaled.x /= aspect;
    
    // Convert to clip space (-1 to 1) by multiplying by 2.0
    gl_Position = vec4(scaled * 2.0, 0.0, 1.0);
    vPosition = position;
  }
`;

const fragmentShader = `
  precision mediump float;
  uniform sampler2D uPalette;
  uniform float uIterations;
  varying vec2 vPosition;

  void main() {
    // Color based on position along the curve
    // Create interesting patterns with both distance and angle
    float dist = length(vPosition);
    float angle = atan(vPosition.y, vPosition.x);
    float t = fract(dist * 1.5 + angle * 0.3);

    vec3 color = texture2D(uPalette, vec2(t, 0.5)).rgb;
    gl_FragColor = vec4(color, 1.0);
  }
`;

export function render(regl, params, canvas) {
  // Generate palette texture for the current color scheme
  const paletteTexture = generatePaletteTexture(regl, params.colorScheme);

  // Calculate iteration level based on params.iterations
  // Map 0-200 iterations to 0-7 levels
  // Sierpinski arrowhead grows as 3^n, so keep it reasonable
  const iterationLevel = Math.max(0, Math.min(7, Math.floor(params.iterations / 28)));

  // Generate vertices for current iteration level
  const vertices = generateSierpinskiArrowhead(iterationLevel);

  const drawArrowhead = regl({
    vert: vertexShader,
    frag: fragmentShader,
    attributes: {
      position: vertices,
    },
    uniforms: {
      uZoom: params.zoom,
      uOffset: [params.offset.x, params.offset.y],
      uResolution: [canvas.width, canvas.height],
      uPalette: paletteTexture,
      uIterations: params.iterations,
      uXScale: params.xScale,
      uYScale: params.yScale,
    },
    viewport: {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
    },
    count: vertices.length / 2,
    primitive: 'line strip',
    lineWidth: 1,
  });

  return drawArrowhead;
}

export const is2D = true;
